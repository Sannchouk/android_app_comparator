import{a5 as t,aF as e,k as s,m as r,q as i,C as n,u as o,w as a,a2 as c,ag as h,bN as u,bM as d,bO as p,c5 as l,c6 as k,c7 as f,c8 as m,c9 as b,ca as g,cb as w,bJ as v,cc as y,cd as S}from"./main.js";import{p as E}from"./layout-e08f9316.js";import{v as q,b as C}from"./fen-f2d95e2d.js";var O={controller(){let t=!1;const e=h(null),s=h("standard"),r=h("white");function i(e){"backbutton"!==e&&t&&a.backbutton.stack.pop(),t=!1}return{open:function(n,o,c="white"){a.backbutton.stack.push(i),e(n),s(o),r(c),t=!0},close:i,fen:e,variant:s,color:r,isOpen:function(){return t}}},view:h=>t("continueFromHere",(()=>r("h2",i("continueFromHere"))),(()=>[!e.has(h.variant())&&s()?r("p.sep",i("playOnline")):null,!e.has(h.variant())&&s()?r("button",{oncreate:n((()=>{h.close();const t=h.fen();t&&E.openAIFromPosition(t)}))},i("playWithTheMachine")):null,!e.has(h.variant())&&s()?r("button",{oncreate:n((()=>{h.close();const t=h.fen();t&&o.openFromPosition(t)}))},i("playWithAFriend")):null,r("p.sep",i("playOffline")),r("button",{oncreate:n((()=>{h.close();const t=h.fen(),e=h.variant(),s=h.color();t&&(q(t,e)&&C(t)?a.set(`/ai/variant/${e}/fen/${encodeURIComponent(t)}/color/${s}`):c.show({text:"Invalid FEN",position:"center",duration:"short"}))}))},i("computer")),r("button",{oncreate:n((()=>{h.close();const t=h.fen(),e=h.variant();t&&(q(t,e)&&C(t)?a.set(`/otb/variant/${e}/fen/${encodeURIComponent(t)}`):c.show({text:"Invalid FEN",position:"center",duration:"short"}))}))},i("overTheBoard"))]),h.isOpen(),h.close)};function R(t,e){let s=u.empty();for(const r of e){const e=t+r;0<=e&&e<64&&Math.abs(d(t)-d(e))<=2&&(s=s.with(e))}return s}function x(t){const e=[];for(let s=0;s<64;s++)e[s]=t(s);return e}const A=x((t=>R(t,[-9,-8,-7,-1,1,7,8,9]))),I=x((t=>R(t,[-17,-15,-10,-6,6,10,15,17]))),M={white:x((t=>R(t,[7,9]))),black:x((t=>R(t,[-7,-9])))};function D(t){return A[t]}function K(t){return I[t]}function P(t,e){return M[t][e]}const V=x((t=>u.fromFile(d(t)).without(t))),z=x((t=>u.fromRank(p(t)).without(t))),F=x((t=>{const e=new u(134480385,2151686160),s=8*(p(t)-d(t));return(s>=0?e.shl64(s):e.shr64(-s)).without(t)})),_=x((t=>{const e=new u(270549120,16909320),s=8*(p(t)+d(t)-7);return(s>=0?e.shl64(s):e.shr64(-s)).without(t)}));function N(t,e,s){let r=s.intersect(e),i=r.bswap64();return r=r.minus64(t),i=i.minus64(t.bswap64()),r.xor(i.bswap64()).intersect(e)}function B(t,e){const s=u.fromSquare(t);return N(s,F[t],e).xor(N(s,_[t],e))}function Q(t,e){return function(t,e){return N(u.fromSquare(t),V[t],e)}(t,e).xor(function(t,e){const s=z[t];let r=e.intersect(s),i=r.rbit64();return r=r.minus64(u.fromSquare(t)),i=i.minus64(u.fromSquare(63-t)),r.xor(i.rbit64()).intersect(s)}(t,e))}function T(t,e){return B(t,e).xor(Q(t,e))}function j(t,e){const s=u.fromSquare(e);return z[t].intersects(s)?z[t].with(t):_[t].intersects(s)?_[t].with(t):F[t].intersects(s)?F[t].with(t):V[t].intersects(s)?V[t].with(t):u.empty()}function $(t,e){return j(t,e).intersect(u.full().shl64(t).xor(u.full().shl64(e))).withoutFirst()}var H;!function(t){t.Empty="ERR_EMPTY",t.OppositeCheck="ERR_OPPOSITE_CHECK",t.ImpossibleCheck="ERR_IMPOSSIBLE_CHECK",t.PawnsOnBackrank="ERR_PAWNS_ON_BACKRANK",t.Kings="ERR_KINGS",t.Variant="ERR_VARIANT"}(H||(H={}));class W extends Error{}function L(t,e){return"white"===t?"a"===e?3:5:"a"===e?59:61}class U{constructor(){}static default(){const t=new U;return t.unmovedRooks=u.corners(),t.rook={white:{a:0,h:7},black:{a:56,h:63}},t.path={white:{a:new u(14,0),h:new u(96,0)},black:{a:new u(0,234881024),h:new u(0,1610612736)}},t}static empty(){const t=new U;return t.unmovedRooks=u.empty(),t.rook={white:{a:void 0,h:void 0},black:{a:void 0,h:void 0}},t.path={white:{a:u.empty(),h:u.empty()},black:{a:u.empty(),h:u.empty()}},t}clone(){const t=new U;return t.unmovedRooks=this.unmovedRooks,t.rook={white:{a:this.rook.white.a,h:this.rook.white.h},black:{a:this.rook.black.a,h:this.rook.black.h}},t.path={white:{a:this.path.white.a,h:this.path.white.h},black:{a:this.path.black.a,h:this.path.black.h}},t}add(t,e,s,r){const i=w(t,e),n=L(t,e);this.unmovedRooks=this.unmovedRooks.with(r),this.rook[t][e]=r,this.path[t][e]=$(r,n).with(n).union($(s,i).with(i)).without(s).without(r)}static fromSetup(t){const e=U.empty(),s=t.unmovedRooks.intersect(t.board.rook);for(const r of l){const i=u.backrank(r),n=t.board.kingOf(r);if(!k(n)||!i.has(n))continue;const o=s.intersect(t.board[r]).intersect(i),a=o.first();k(a)&&a<n&&e.add(r,"a",n,a);const c=o.last();k(c)&&n<c&&e.add(r,"h",n,c)}return e}discardRook(t){if(this.unmovedRooks.has(t)){this.unmovedRooks=this.unmovedRooks.without(t);for(const e of l)for(const s of f)this.rook[e][s]===t&&(this.rook[e][s]=void 0)}}discardSide(t){this.unmovedRooks=this.unmovedRooks.diff(u.backrank(t)),this.rook[t].a=void 0,this.rook[t].h=void 0}}class G extends class{constructor(t){this.rules=t}kingAttackers(t,e,s){return function(t,e,s,r){return s[e].intersect(Q(t,r).intersect(s.rooksAndQueens()).union(B(t,r).intersect(s.bishopsAndQueens())).union(K(t).intersect(s.knight)).union(D(t).intersect(s.king)).union(P(g(e),t).intersect(s.pawn)))}(t,e,this.board,s)}dropDests(t){return u.empty()}playCaptureAt(t,e){this.halfmoves=0,"rook"===e.role&&this.castles.discardRook(t),this.pockets&&this.pockets[g(e.color)][e.role]++}ctx(){const t=this.isVariantEnd(),e=this.board.kingOf(this.turn);if(!k(e))return{king:e,blockers:u.empty(),checkers:u.empty(),variantEnd:t,mustCapture:!1};const s=Q(e,u.empty()).intersect(this.board.rooksAndQueens()).union(B(e,u.empty()).intersect(this.board.bishopsAndQueens())).intersect(this.board[g(this.turn)]);let r=u.empty();for(const t of s){const s=$(e,t).intersect(this.board.occupied);s.moreThanOne()||(r=r.union(s))}return{king:e,blockers:r,checkers:this.kingAttackers(e,g(this.turn),this.board.occupied),variantEnd:t,mustCapture:!1}}clone(){var t,e;const s=new this.constructor;return s.board=this.board.clone(),s.pockets=null===(t=this.pockets)||void 0===t?void 0:t.clone(),s.turn=this.turn,s.castles=this.castles.clone(),s.epSquare=this.epSquare,s.remainingChecks=null===(e=this.remainingChecks)||void 0===e?void 0:e.clone(),s.halfmoves=this.halfmoves,s.fullmoves=this.fullmoves,s}equalsIgnoreMoves(t){var e,s;return this.rules===t.rules&&(this.pockets?this.board.equals(t.board):this.board.equalsIgnorePromoted(t.board))&&(t.pockets&&(null===(e=this.pockets)||void 0===e?void 0:e.equals(t.pockets))||!this.pockets&&!t.pockets)&&this.turn===t.turn&&this.castles.unmovedRooks.equals(t.castles.unmovedRooks)&&this.legalEpSquare()===t.legalEpSquare()&&(t.remainingChecks&&(null===(s=this.remainingChecks)||void 0===s?void 0:s.equals(t.remainingChecks))||!this.remainingChecks&&!t.remainingChecks)}toSetup(){var t,e;return{board:this.board.clone(),pockets:null===(t=this.pockets)||void 0===t?void 0:t.clone(),turn:this.turn,unmovedRooks:this.castles.unmovedRooks,epSquare:this.legalEpSquare(),remainingChecks:null===(e=this.remainingChecks)||void 0===e?void 0:e.clone(),halfmoves:Math.min(this.halfmoves,150),fullmoves:Math.min(Math.max(this.fullmoves,1),9999)}}isInsufficientMaterial(){return l.every((t=>this.hasInsufficientMaterial(t)))}hasDests(t){t=t||this.ctx();for(const e of this.board[this.turn])if(this.dests(e,t).nonEmpty())return!0;return this.dropDests(t).nonEmpty()}isLegal(t,e){if(v(t))return!(!this.pockets||this.pockets[this.turn][t.role]<=0)&&(("pawn"!==t.role||!u.backranks().has(t.to))&&this.dropDests(e).has(t.to));{if("pawn"===t.promotion)return!1;if("king"===t.promotion&&"antichess"!==this.rules)return!1;if(!!t.promotion!==(this.board.pawn.has(t.from)&&u.backranks().has(t.to)))return!1;const s=this.dests(t.from,e);return s.has(t.to)||s.has(this.normalizeMove(t).to)}}isCheck(){const t=this.board.kingOf(this.turn);return k(t)&&this.kingAttackers(t,g(this.turn),this.board.occupied).nonEmpty()}isEnd(t){return!!(t?t.variantEnd:this.isVariantEnd())||(this.isInsufficientMaterial()||!this.hasDests(t))}isCheckmate(t){return!(t=t||this.ctx()).variantEnd&&t.checkers.nonEmpty()&&!this.hasDests(t)}isStalemate(t){return!(t=t||this.ctx()).variantEnd&&t.checkers.isEmpty()&&!this.hasDests(t)}outcome(t){const e=this.variantOutcome(t);return e||(t=t||this.ctx(),this.isCheckmate(t)?{winner:g(this.turn)}:this.isInsufficientMaterial()||this.isStalemate(t)?{winner:void 0}:void 0)}allDests(t){t=t||this.ctx();const e=new Map;if(t.variantEnd)return e;for(const s of this.board[this.turn])e.set(s,this.dests(s,t));return e}castlingSide(t){if(v(t))return;const e=t.to-t.from;return(2===Math.abs(e)||this.board[this.turn].has(t.to))&&this.board.king.has(t.from)?e>0?"h":"a":void 0}normalizeMove(t){const e=this.castlingSide(t);if(!e)return t;const s=this.castles.rook[this.turn][e];return{from:t.from,to:k(s)?s:t.to}}play(t){const e=this.turn,s=this.epSquare,r=this.castlingSide(t);if(this.epSquare=void 0,this.halfmoves+=1,"black"===e&&(this.fullmoves+=1),this.turn=g(e),v(t))this.board.set(t.to,{role:t.role,color:e}),this.pockets&&this.pockets[e][t.role]--,"pawn"===t.role&&(this.halfmoves=0);else{const i=this.board.take(t.from);if(!i)return;let n;if("pawn"===i.role){this.halfmoves=0,t.to===s&&(n=this.board.take(t.to+("white"===e?-8:8)));const r=t.from-t.to;16===Math.abs(r)&&8<=t.from&&t.from<=55&&(this.epSquare=t.from+t.to>>1),t.promotion&&(i.role=t.promotion,i.promoted=!0)}else if("rook"===i.role)this.castles.discardRook(t.from);else if("king"===i.role){if(r){const t=this.castles.rook[e][r];if(k(t)){const s=this.board.take(t);this.board.set(w(e,r),i),s&&this.board.set(L(e,r),s)}}this.castles.discardSide(e)}if(!r){const e=this.board.set(t.to,i)||n;e&&this.playCaptureAt(t.to,e)}}this.remainingChecks&&this.isCheck()&&(this.remainingChecks[e]=Math.max(this.remainingChecks[e]-1,0))}legalEpSquare(t){if(!k(this.epSquare))return;t=t||this.ctx();const e=this.board.pieces(this.turn,"pawn").intersect(P(g(this.turn),this.epSquare));for(const s of e)if(this.dests(s,t).has(this.epSquare))return this.epSquare}}{constructor(t){super(t||"chess")}static default(){const t=new this;return t.board=m.default(),t.pockets=void 0,t.turn="white",t.castles=U.default(),t.epSquare=void 0,t.remainingChecks=void 0,t.halfmoves=0,t.fullmoves=1,t}static fromSetup(t){const e=new this;return e.board=t.board.clone(),e.pockets=void 0,e.turn=t.turn,e.castles=U.fromSetup(t),e.epSquare=e.validEpSquare(t.epSquare),e.remainingChecks=void 0,e.halfmoves=t.halfmoves,e.fullmoves=t.fullmoves,e.validate().map((t=>e))}clone(){return super.clone()}validate(){if(this.board.occupied.isEmpty())return b.err(new W(H.Empty));if(2!==this.board.king.size())return b.err(new W(H.Kings));if(!k(this.board.kingOf(this.turn)))return b.err(new W(H.Kings));const t=this.board.kingOf(g(this.turn));return k(t)?this.kingAttackers(t,this.turn,this.board.occupied).nonEmpty()?b.err(new W(H.OppositeCheck)):u.backranks().intersects(this.board.pawn)?b.err(new W(H.PawnsOnBackrank)):this.validateCheckers():b.err(new W(H.Kings))}validateCheckers(){const t=this.board.kingOf(this.turn);if(k(t)){const e=this.kingAttackers(t,g(this.turn),this.board.occupied);if(e.size()>2||2===e.size()&&j(e.first(),e.last()).has(t))return b.err(new W(H.ImpossibleCheck));if(k(this.epSquare))for(const s of e)if(j(s,this.epSquare).has(t))return b.err(new W(H.ImpossibleCheck))}return b.ok(void 0)}validEpSquare(t){if(!k(t))return;const e="white"===this.turn?5:2,s="white"===this.turn?8:-8;if(p(t)!==e)return;if(this.board.occupied.has(t+s))return;const r=t-s;return this.board.pawn.has(r)&&this.board[g(this.turn)].has(r)?t:void 0}castlingDest(t,e){if(!k(e.king)||e.checkers.nonEmpty())return u.empty();const s=this.castles.rook[this.turn][t];if(!k(s))return u.empty();if(this.castles.path[this.turn][t].intersects(this.board.occupied))return u.empty();const r=w(this.turn,t),i=$(e.king,r),n=this.board.occupied.without(e.king);for(const t of i)if(this.kingAttackers(t,g(this.turn),n).nonEmpty())return u.empty();const o=L(this.turn,t),a=this.board.occupied.toggle(e.king).toggle(s).toggle(o);return this.kingAttackers(r,g(this.turn),a).nonEmpty()?u.empty():u.fromSquare(s)}canCaptureEp(t,e){if(!k(this.epSquare))return!1;if(!P(this.turn,t).has(this.epSquare))return!1;if(!k(e.king))return!0;const s=this.epSquare+("white"===this.turn?-8:8),r=this.board.occupied.toggle(t).toggle(this.epSquare).toggle(s);return!this.kingAttackers(e.king,g(this.turn),r).intersects(r)}pseudoDests(t,e){if(e.variantEnd)return u.empty();const s=this.board.get(t);if(!s||s.color!==this.turn)return u.empty();let r=function(t,e,s){switch(t.role){case"pawn":return P(t.color,e);case"knight":return K(e);case"bishop":return B(e,s);case"rook":return Q(e,s);case"queen":return T(e,s);case"king":return D(e)}}(s,t,this.board.occupied);if("pawn"===s.role){let e=this.board[g(this.turn)];k(this.epSquare)&&(e=e.with(this.epSquare)),r=r.intersect(e);const s="white"===this.turn?8:-8,i=t+s;if(0<=i&&i<64&&!this.board.occupied.has(i)){r=r.with(i);const e=i+s;("white"===this.turn?t<16:t>=48)&&!this.board.occupied.has(e)&&(r=r.with(e))}return r}return r=r.diff(this.board[this.turn]),t===e.king?r.union(this.castlingDest("a",e)).union(this.castlingDest("h",e)):r}dests(t,e){if((e=e||this.ctx()).variantEnd)return u.empty();const s=this.board.get(t);if(!s||s.color!==this.turn)return u.empty();let r,i;if("pawn"===s.role){r=P(this.turn,t).intersect(this.board[g(this.turn)]);const s="white"===this.turn?8:-8,n=t+s;if(0<=n&&n<64&&!this.board.occupied.has(n)){r=r.with(n);const e=n+s;("white"===this.turn?t<16:t>=48)&&!this.board.occupied.has(e)&&(r=r.with(e))}if(k(this.epSquare)&&this.canCaptureEp(t,e)){const t=this.epSquare-s;(e.checkers.isEmpty()||e.checkers.singleSquare()===t)&&(i=u.fromSquare(this.epSquare))}}else r="bishop"===s.role?B(t,this.board.occupied):"knight"===s.role?K(t):"rook"===s.role?Q(t,this.board.occupied):"queen"===s.role?T(t,this.board.occupied):D(t);if(r=r.diff(this.board[this.turn]),k(e.king)){if("king"===s.role){const s=this.board.occupied.without(t);for(const t of r)this.kingAttackers(t,g(this.turn),s).nonEmpty()&&(r=r.without(t));return r.union(this.castlingDest("a",e)).union(this.castlingDest("h",e))}if(e.checkers.nonEmpty()){const t=e.checkers.singleSquare();if(!k(t))return u.empty();r=r.intersect($(t,e.king).with(t))}e.blockers.has(t)&&(r=r.intersect(j(t,e.king)))}return i&&(r=r.union(i)),r}isVariantEnd(){return!1}variantOutcome(t){}hasInsufficientMaterial(t){if(this.board[t].intersect(this.board.pawn.union(this.board.rooksAndQueens())).nonEmpty())return!1;if(this.board[t].intersects(this.board.knight))return this.board[t].size()<=2&&this.board[g(t)].diff(this.board.king).diff(this.board.queen).isEmpty();if(this.board[t].intersects(this.board.bishop)){return(!this.board.bishop.intersects(u.darkSquares())||!this.board.bishop.intersects(u.lightSquares()))&&this.board.pawn.isEmpty()&&this.board.knight.isEmpty()}return!0}}class J extends G{constructor(){super("crazyhouse")}static default(){const t=super.default();return t.pockets=y.empty(),t}static fromSetup(t){return super.fromSetup(t).map((e=>(e.pockets=t.pockets?t.pockets.clone():y.empty(),e)))}validate(){return super.validate().chain((t=>this.pockets&&(this.pockets.white.king>0||this.pockets.black.king>0)?b.err(new W(H.Kings)):(this.pockets?this.pockets.count():0)+this.board.occupied.size()>64?b.err(new W(H.Variant)):b.ok(void 0)))}clone(){return super.clone()}hasInsufficientMaterial(t){return this.pockets?this.board.occupied.size()+this.pockets.count()<=3&&this.board.pawn.isEmpty()&&this.board.promoted.isEmpty()&&this.board.rooksAndQueens().isEmpty()&&this.pockets.white.pawn<=0&&this.pockets.black.pawn<=0&&this.pockets.white.rook<=0&&this.pockets.black.rook<=0&&this.pockets.white.queen<=0&&this.pockets.black.queen<=0:super.hasInsufficientMaterial(t)}dropDests(t){var e,s;const r=this.board.occupied.complement().intersect((null===(e=this.pockets)||void 0===e?void 0:e[this.turn].hasNonPawns())?u.full():(null===(s=this.pockets)||void 0===s?void 0:s[this.turn].hasPawns())?u.backranks().complement():u.empty());if(t=t||this.ctx(),k(t.king)&&t.checkers.nonEmpty()){const e=t.checkers.singleSquare();return k(e)?r.intersect($(e,t.king)):u.empty()}return r}}class Y extends G{constructor(){super("atomic")}static default(){return super.default()}static fromSetup(t){return super.fromSetup(t)}clone(){return super.clone()}validate(){if(this.board.occupied.isEmpty())return b.err(new W(H.Empty));if(this.board.king.size()>2)return b.err(new W(H.Kings));const t=this.board.kingOf(g(this.turn));return k(t)?this.kingAttackers(t,this.turn,this.board.occupied).nonEmpty()?b.err(new W(H.OppositeCheck)):u.backranks().intersects(this.board.pawn)?b.err(new W(H.PawnsOnBackrank)):b.ok(void 0):b.err(new W(H.Kings))}kingAttackers(t,e,s){const r=this.board.pieces(e,"king");return r.isEmpty()||D(t).intersects(r)?u.empty():super.kingAttackers(t,e,s)}playCaptureAt(t,e){super.playCaptureAt(t,e),this.board.take(t);for(const e of D(t).intersect(this.board.occupied).diff(this.board.pawn)){const t=this.board.take(e);t&&"rook"===t.role&&this.castles.discardRook(e),t&&"king"===t.role&&this.castles.discardSide(t.color)}}hasInsufficientMaterial(t){if(this.board.pieces(g(t),"king").isEmpty())return!1;if(this.board[t].diff(this.board.king).isEmpty())return!0;if(this.board[g(t)].diff(this.board.king).nonEmpty()){if(this.board.occupied.equals(this.board.bishop.union(this.board.king))){if(!this.board.bishop.intersect(this.board.white).intersects(u.darkSquares()))return!this.board.bishop.intersect(this.board.black).intersects(u.lightSquares());if(!this.board.bishop.intersect(this.board.white).intersects(u.lightSquares()))return!this.board.bishop.intersect(this.board.black).intersects(u.darkSquares())}return!1}return!this.board.queen.nonEmpty()&&!this.board.pawn.nonEmpty()&&(!!this.board.knight.union(this.board.bishop).union(this.board.rook).isSingleSquare()||!!this.board.occupied.equals(this.board.knight.union(this.board.king))&&this.board.knight.size()<=2)}dests(t,e){e=e||this.ctx();let s=u.empty();for(const r of this.pseudoDests(t,e)){const e=this.clone();e.play({from:t,to:r});const i=e.board.kingOf(this.turn);!k(i)||k(e.board.kingOf(e.turn))&&!e.kingAttackers(i,e.turn,e.board.occupied).isEmpty()||(s=s.with(r))}return s}isVariantEnd(){return!!this.variantOutcome()}variantOutcome(t){for(const t of l)if(this.board.pieces(t,"king").isEmpty())return{winner:g(t)}}}class X extends G{constructor(){super("antichess")}static default(){const t=super.default();return t.castles=U.empty(),t}static fromSetup(t){return super.fromSetup(t).map((t=>(t.castles=U.empty(),t)))}clone(){return super.clone()}validate(){return this.board.occupied.isEmpty()?b.err(new W(H.Empty)):u.backranks().intersects(this.board.pawn)?b.err(new W(H.PawnsOnBackrank)):b.ok(void 0)}kingAttackers(t,e,s){return u.empty()}ctx(){const t=super.ctx(),e=this.board[g(this.turn)];for(const s of this.board[this.turn])if(this.pseudoDests(s,t).intersects(e)){t.mustCapture=!0;break}return t}dests(t,e){e=e||this.ctx();const s=this.pseudoDests(t,e);return e.mustCapture?s.intersect(this.board[g(this.turn)]):s}hasInsufficientMaterial(t){if(this.board.occupied.equals(this.board.bishop)){const e=this.board[t].intersects(u.lightSquares()),s=this.board[t].intersects(u.darkSquares()),r=this.board[g(t)].isDisjoint(u.lightSquares()),i=this.board[g(t)].isDisjoint(u.darkSquares());return e&&r||s&&i}return!1}isVariantEnd(){return this.board[this.turn].isEmpty()}variantOutcome(t){if((t=t||this.ctx()).variantEnd||this.isStalemate(t))return{winner:this.turn}}}class Z extends G{constructor(){super("kingofthehill")}static default(){return super.default()}static fromSetup(t){return super.fromSetup(t)}clone(){return super.clone()}hasInsufficientMaterial(t){return!1}isVariantEnd(){return this.board.king.intersects(u.center())}variantOutcome(t){for(const t of l)if(this.board.pieces(t,"king").intersects(u.center()))return{winner:t}}}class tt extends G{constructor(){super("3check")}static default(){const t=super.default();return t.remainingChecks=S.default(),t}static fromSetup(t){return super.fromSetup(t).map((e=>(e.remainingChecks=t.remainingChecks?t.remainingChecks.clone():S.default(),e)))}clone(){return super.clone()}hasInsufficientMaterial(t){return this.board.pieces(t,"king").equals(this.board[t])}isVariantEnd(){return!!this.remainingChecks&&(this.remainingChecks.white<=0||this.remainingChecks.black<=0)}variantOutcome(t){if(this.remainingChecks)for(const t of l)if(this.remainingChecks[t]<=0)return{winner:t}}}class et extends G{constructor(){super("racingkings")}static default(){const t=new this;return t.board=m.racingKings(),t.pockets=void 0,t.turn="white",t.castles=U.empty(),t.epSquare=void 0,t.remainingChecks=void 0,t.halfmoves=0,t.fullmoves=1,t}static fromSetup(t){return super.fromSetup(t).map((t=>(t.castles=U.empty(),t)))}validate(){return this.isCheck()?b.err(new W(H.ImpossibleCheck)):this.board.pawn.nonEmpty()?b.err(new W(H.Variant)):super.validate()}clone(){return super.clone()}dests(t,e){if(t===(e=e||this.ctx()).king)return super.dests(t,e);let s=u.empty();for(const r of super.dests(t,e)){const e={from:t,to:r},i=this.clone();i.play(e),i.isCheck()||(s=s.with(r))}return s}hasInsufficientMaterial(t){return!1}isVariantEnd(){const t=u.fromRank(7),e=this.board.king.intersect(t);if(e.isEmpty())return!1;if("white"===this.turn||e.intersects(this.board.black))return!0;const s=this.board.kingOf("black");if(k(s)){const e=this.board.occupied.without(s);for(const r of D(s).intersect(t).diff(this.board.black))if(this.kingAttackers(r,"white",e).isEmpty())return!1}return!0}variantOutcome(t){if(t?!t.variantEnd:!this.isVariantEnd())return;const e=u.fromRank(7),s=this.board.pieces("black","king").intersects(e),r=this.board.pieces("white","king").intersects(e);return s&&!r?{winner:"black"}:r&&!s?{winner:"white"}:{winner:void 0}}}class st extends G{constructor(){super("horde")}static default(){const t=new this;return t.board=m.horde(),t.pockets=void 0,t.turn="white",t.castles=U.default(),t.castles.discardSide("white"),t.epSquare=void 0,t.remainingChecks=void 0,t.halfmoves=0,t.fullmoves=1,t}static fromSetup(t){return super.fromSetup(t)}validate(){if(this.board.occupied.isEmpty())return b.err(new W(H.Empty));if(!this.board.king.isSingleSquare())return b.err(new W(H.Kings));if(!this.board.king.diff(this.board.promoted).isSingleSquare())return b.err(new W(H.Kings));const t=this.board.kingOf(g(this.turn));if(k(t)&&this.kingAttackers(t,this.turn,this.board.occupied).nonEmpty())return b.err(new W(H.OppositeCheck));for(const t of l)if(this.board.pieces(t,"pawn").intersects(u.backrank(g(t))))return b.err(new W(H.PawnsOnBackrank));return this.validateCheckers()}clone(){return super.clone()}hasInsufficientMaterial(t){return!1}isVariantEnd(){return this.board.white.isEmpty()||this.board.black.isEmpty()}variantOutcome(t){return this.board.white.isEmpty()?{winner:"black"}:this.board.black.isEmpty()?{winner:"white"}:void 0}}function rt(t,e){switch(t){case"chess":return G.fromSetup(e);case"antichess":return X.fromSetup(e);case"atomic":return Y.fromSetup(e);case"horde":return st.fromSetup(e);case"racingkings":return et.fromSetup(e);case"kingofthehill":return Z.fromSetup(e);case"3check":return tt.fromSetup(e);case"crazyhouse":return J.fromSetup(e)}}export{U as C,K as a,B as b,O as c,D as k,T as q,Q as r,rt as s};
